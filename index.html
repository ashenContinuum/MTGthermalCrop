<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Proxy Splitter (2‑label)</title>
  <style>
    :root { --bg:#0f1115; --panel:#171923; --panel2:#1e2230; --text:#e6e8f0; --muted:#9aa4b2; --accent:#7aa2ff; --accent2:#4fd1c5; --warn:#f6ad55; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";background:linear-gradient(180deg,#0b0d12,#0f1115 120%);color:var(--text)}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px}
    .panel{background:var(--panel);border:1px solid #23283a;border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    h1{font-size:18px;margin:0 0 8px;letter-spacing:.2px}
    h2{font-size:14px;margin:14px 0 8px;color:var(--muted);font-weight:600}
    label{display:block;margin:8px 0 4px;color:var(--muted)}
    input[type=number],select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #2a3045;background:var(--panel2);color:var(--text)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 12px;border-radius:10px;border:1px solid #2a3045;background:#1b2030;color:var(--text);cursor:pointer;user-select:none;transition:.15s ease background,.15s ease transform}
    .btn:hover{background:#232a40}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:linear-gradient(180deg,#283b73,#1f2b52);border-color:#31478e}
    .btn.accent{background:linear-gradient(180deg,#145f56,#0f4740);border-color:#1b7a70}
    .btn.warn{background:linear-gradient(180deg,#7b4a12,#5a360d);border-color:#9c6019}
    .muted{color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:#0f1320;border:1px solid #23283a;border-radius:12px;padding:10px}
    .preview-wrap{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    canvas{width:100%;background:#0a0c12;border-radius:10px;border:1px solid #23283a}
    .bar{display:flex;gap:8px;flex-wrap:wrap}
    .kbd{font:12px/1.4 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0c0f19;border:1px solid #23283a;border-radius:6px;padding:2px 6px;color:#c8d0e0}
    .slider-row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px}
    input[type=range]{width:100%}
    .note{font-size:12px;color:var(--muted)}
    .pill{font-size:11px;padding:2px 8px;border-radius:999px;background:#1e2230;border:1px solid #2a3045;color:#aab3c5}
    .chk{display:flex;align-items:center;gap:8px;margin-top:6px;color:var(--muted)}
    .subtle{font-size:12px;color:#9aa4b2;margin-top:4px}
  </style>
</head>
<body>
  <div class="wrap">
    <section class="panel">
      <h1>MTG Proxy Splitter <span class="pill">two‑label</span></h1>
      <p class="muted">Split a card image into <em>Art</em> (top label) and <em>Text</em> (bottom label). The tool also relocates the <strong>Name + Mana Cost</strong> band from the top to directly above the lower text block. Outputs two PNGs. Rotation optional (90° clockwise).</p>

      <h2>1) Source image</h2>
      <input id="file" type="file" accept="image/*" />
      <div class="row" style="margin-top:8px">
        <button id="fitPreset" class="btn">Auto preset: Classic frame</button>
        <button id="reset" class="btn warn">Reset sliders</button>
      </div>

      <h2>2) Regions (percent of height)</h2>
      <div class="slider-row">
        <label>Top band height (Name+Mana) <span id="vTop" class="pill"></span></label>
        <input id="topBand" type="range" min="1" max="70" value="10" />
      </div>
      <div class="slider-row">
        <label>Art top <span id="vArtTop" class="pill"></span></label>
        <input id="artTop" type="range" min="1" max="70" value="11" />
      </div>
      <div class="slider-row">
        <label>Art bottom <span id="vArtBot" class="pill"></span></label>
        <input id="artBot" type="range" min="1" max="70" value="56" />
      </div>
      <label class="chk"><input id="enforce" type="checkbox" checked /> Prevent overlap (lock order & bounds)</label>
      <div class="note">Typical classic frame: Name+Mana ≈ 10–12%, Art ≈ 11% → 56%, remainder is type+rules text.</div>

      <h2>2a) Art horizontal crop (affects <em>Art</em> label only)</h2>
      <div class="slider-row">
        <label>Art crop — left <span id="vArtL" class="pill"></span></label>
        <input id="artCropL" type="range" min="0" max="45" value="0" />
      </div>
      <div class="slider-row">
        <label>Art crop — right <span id="vArtR" class="pill"></span></label>
        <input id="artCropR" type="range" min="0" max="45" value="0" />
      </div>
      <div class="subtle">When rotated 90° clockwise, these behave as top/bottom trims. With <em>Prevent overlap</em> on, the tool keeps at least 10% of the art width visible; turn it off to allow extreme/overlapping crops.</div>

      <h2>3) Output sizing</h2>
      <div class="grid2">
        <div>
          <label>Label width (mm)</label>
          <input id="mmW" type="number" min="10" max="200" step="0.1" value="50" />
        </div>
        <div>
          <label>Label height (mm)</label>
          <input id="mmH" type="number" min="10" max="200" step="0.1" value="80" />
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label>Export DPI (for pixel sizing)</label>
          <input id="dpi" type="number" min="72" max="600" step="1" value="300" />
        </div>
        <div>
          <label>Rotate 90° clockwise</label>
          <select id="rotate">
            <option value="no">No</option>
            <option value="yes">Yes</option>
          </select>
        </div>
      </div>

      <h2>4) Actions</h2>
      <div class="bar">
        <button id="render" class="btn primary">Render previews</button>
        <button id="exportTop" class="btn accent" disabled>Download Art label</button>
        <button id="exportBottom" class="btn accent" disabled>Download Text label</button>
      </div>
      <label class="chk"><input id="trimExport" type="checkbox" checked /> Trim blank white margins on export</label>
      <p class="note" style="margin-top:8px">Tip: Hold <span class="kbd">Shift</span> while dragging sliders for finer control. This tool doesn’t do grayscale/B&amp;W conversion — your printer app will handle that.</p>" style="margin-top:8px">Tip: Hold <span class="kbd">Shift</span> while dragging sliders for finer control. This tool doesn’t do grayscale/B&amp;W conversion — your printer app will handle that.</p>
    </section>

    <section class="panel">
      <h2 style="margin-top:0">Previews</h2>
      <div class="preview-wrap">
        <div class="card">
          <div class="bar" style="margin-bottom:6px"><strong>Art (top label)</strong></div>
          <canvas id="prevTop"></canvas>
        </div>
        <div class="card">
          <div class="bar" style="margin-bottom:6px"><strong>Text (bottom label)</strong></div>
          <canvas id="prevBottom"></canvas>
        </div>
      </div>

      <h2>Guides</h2>
      <div class="note">Rotation, if enabled, is applied to the <em>image content only</em>; label size stays fixed.</div>
    </section>
  </div>

  <script>
    // utils
    const mmToPx = (mm,dpi)=> Math.round((mm/25.4)*dpi);
    const el = id => document.getElementById(id);

    // state
    const S = {
      img:null, srcW:0, srcH:0,
      topPct:10, artTopPct:11, artBotPct:56,
      artCropL:0, artCropR:0, // percent of art width to crop
      labelWmm:50, labelHmm:80, dpi:300, rotate:false,
      topCanvas:null, bottomCanvas:null
    };

    // els
    const file = el('file');
    const topBand = el('topBand');
    const artTop = el('artTop');
    const artBot = el('artBot');
    const vTop = el('vTop');
    const vArtTop = el('vArtTop');
    const vArtBot = el('vArtBot');
    const vArtL = el('vArtL');
    const vArtR = el('vArtR');
    const artCropL = el('artCropL');
    const artCropR = el('artCropR');
    const enforce = el('enforce');
    const mmW = el('mmW');
    const mmH = el('mmH');
    const dpi = el('dpi');
    const rotate = el('rotate');
    const fitPreset = el('fitPreset');
    const resetBtn = el('reset');
    const renderBtn = el('render');
    const exportTop = el('exportTop');
    const trimExport = el('trimExport');
    const exportBottom = el('exportBottom');
    const prevTop = el('prevTop');
    const prevBottom = el('prevBottom');

    // image load
    file.addEventListener('change', e => {
      const f = e.target.files && e.target.files[0]; if(!f) return;
      const img = new Image();
      img.onload = ()=>{ S.img=img; S.srcW=img.naturalWidth; S.srcH=img.naturalHeight; drawPreviews(); };
      img.src = URL.createObjectURL(f);
    });

    // helpers
    function syncBadges(){
      vTop.textContent=S.topPct+'%';
      vArtTop.textContent=S.artTopPct+'%';
      vArtBot.textContent=S.artBotPct+'%';
      vArtL.textContent=S.artCropL+'%';
      vArtR.textContent=S.artCropR+'%';
    }

    function clampToInput(val, input){
      return Math.max(parseInt(input.min||'0',10), Math.min(parseInt(input.max||'100',10), val));
    }

    function enforceOrder(){
      if(!enforce.checked){
        // only clamp to slider min/max
        S.topPct = clampToInput(S.topPct, topBand);
        S.artTopPct = clampToInput(S.artTopPct, artTop);
        S.artBotPct = clampToInput(S.artBotPct, artBot);
        S.artCropL = clampToInput(S.artCropL, artCropL);
        S.artCropR = clampToInput(S.artCropR, artCropR);
        topBand.value=S.topPct; artTop.value=S.artTopPct; artBot.value=S.artBotPct; artCropL.value=S.artCropL; artCropR.value=S.artCropR; syncBadges();
        return;
      }
      // Enforced: top <= artTop < artBot; and keep at least 10% of art width after crops
      if(S.topPct >= S.artTopPct) S.artTopPct = S.topPct + 1;
      if(S.artTopPct >= S.artBotPct) S.artBotPct = S.artTopPct + 1;
      S.topPct = clampToInput(S.topPct, topBand);
      S.artTopPct = clampToInput(S.artTopPct, artTop);
      S.artBotPct = clampToInput(S.artBotPct, artBot);
      // For crops, ensure left+right ≤ 90 when enforcing (leave ≥10% width)
      S.artCropL = clampToInput(S.artCropL, artCropL);
      S.artCropR = clampToInput(S.artCropR, artCropR);
      const sum = S.artCropL + S.artCropR;
      if(sum > 90){
        // scale down proportionally to fit 90
        const scale = 90 / sum;
        S.artCropL = Math.round(S.artCropL * scale);
        S.artCropR = Math.round(S.artCropR * scale);
      }
      topBand.value=S.topPct; artTop.value=S.artTopPct; artBot.value=S.artBotPct; artCropL.value=S.artCropL; artCropR.value=S.artCropR; syncBadges();
    }

    function readControls(){
      S.topPct = parseInt(topBand.value,10);
      S.artTopPct = parseInt(artTop.value,10);
      S.artBotPct = parseInt(artBot.value,10);
      S.artCropL = parseInt(artCropL.value,10);
      S.artCropR = parseInt(artCropR.value,10);
      S.labelWmm = parseFloat(mmW.value);
      S.labelHmm = parseFloat(mmH.value);
      S.dpi = parseInt(dpi.value,10);
      S.rotate = (rotate.value==='yes');
      enforceOrder();
    }

    [topBand,artTop,artBot,artCropL,artCropR,mmW,mmH,dpi,rotate,enforce].forEach(inp=>inp.addEventListener('input',()=>{ readControls(); drawPreviews(); }));
    fitPreset.addEventListener('click',()=>{ topBand.value=10; artTop.value=11; artBot.value=56; artCropL.value=0; artCropR.value=0; readControls(); drawPreviews(); });
    resetBtn.addEventListener('click',()=>{ topBand.value=10; artTop.value=11; artBot.value=56; artCropL.value=0; artCropR.value=0; mmW.value=50; mmH.value=80; dpi.value=300; rotate.value='no'; enforce.checked=true; readControls(); drawPreviews(); });
    renderBtn.addEventListener('click',()=>{ readControls(); drawPreviews(true); });

    // canvas helpers
    function mkCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
    function cropCanvas(srcImg,sx,sy,sw,sh){ const c=mkCanvas(Math.max(1,Math.round(sw)), Math.max(1,Math.round(sh))); const ctx=c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; ctx.drawImage(srcImg,sx,sy,sw,sh,0,0,c.width,c.height); return c; }
    function stackVertical(canvases,outW,outH){ const c=mkCanvas(outW,outH); const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,outW,outH); const totalH=canvases.reduce((s,x)=>s+x.height,0); let y=0; canvases.forEach(cv=>{ const h=Math.round((cv.height/totalH)*outH); ctx.drawImage(cv,0,y,outW,h); y+=h; }); return c; }
    function rotate90cw(canvas){ const c=mkCanvas(canvas.height, canvas.width); const ctx=c.getContext('2d'); ctx.translate(c.width,0); ctx.rotate(Math.PI/2); ctx.drawImage(canvas,0,0); return c; }

    // drawing
    function drawPreviews(enableExport=false){
      syncBadges();

      const labelPxW = mmToPx(S.labelWmm, S.dpi);
      const labelPxH = mmToPx(S.labelHmm, S.dpi);
      const ctxTop = prevTop.getContext('2d');
      const ctxBot = prevBottom.getContext('2d');
      prevTop.width=labelPxW; prevTop.height=labelPxH; prevBottom.width=labelPxW; prevBottom.height=labelPxH;
      ctxTop.clearRect(0,0,prevTop.width,prevTop.height); ctxBot.clearRect(0,0,prevBottom.width,prevBottom.height);

      if(!S.img){ exportTop.disabled=exportBottom.disabled=true; return; }

      const H=S.srcH, W=S.srcW;
      const topPx=Math.round(H*(S.topPct/100));
      const artTopPx=Math.round(H*(S.artTopPct/100));
      const artBotPx=Math.round(H*(S.artBotPct/100));

      const topBandC=cropCanvas(S.img,0,0,W,topPx);

      // raw art slice
      let artCraw=cropCanvas(S.img,0,artTopPx,W,artBotPx-artTopPx);
      // apply left/right crops on art (percent of art width)
      const aW = artCraw.width; const aH = artCraw.height;
      let cropLpx = Math.round(aW*(S.artCropL/100));
      let cropRpx = Math.round(aW*(S.artCropR/100));
      // with enforce off, allow extreme values but keep at least 1px
      if(cropLpx + cropRpx >= aW) {
        if(enforce.checked){ const scale=(aW-1)/(cropLpx+cropRpx||1); cropLpx = Math.floor(cropLpx*scale); cropRpx = Math.floor(cropRpx*scale); }
        else { cropRpx = Math.max(0, aW-1-cropLpx); }
      }
      if(cropLpx>0 || cropRpx>0){ artCraw = cropCanvas(artCraw, cropLpx, 0, aW - cropLpx - cropRpx, aH); }

      const lowerTextC=cropCanvas(S.img,0,artBotPx,W,H-artBotPx);

      // rotate content (not label) if requested
      const artSrc = S.rotate ? rotate90cw(artCraw) : artCraw;
      const stackedRaw = stackVertical([topBandC, lowerTextC], W, topBandC.height + lowerTextC.height);
      const bottomSrc = S.rotate ? rotate90cw(stackedRaw) : stackedRaw;

      // fit into fixed label size
      const artOut = mkCanvas(labelPxW,labelPxH);
      { const ctx=artOut.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; const srcAR=artSrc.width/artSrc.height; const dstAR=artOut.width/artOut.height; let dw,dh,dx,dy; if(srcAR>dstAR){ dw=artOut.width; dh=Math.round(dw/srcAR); dx=0; dy=Math.round((artOut.height-dh)/2);} else { dh=artOut.height; dw=Math.round(dh*srcAR); dx=Math.round((artOut.width-dw)/2); dy=0;} ctx.fillStyle='#fff'; ctx.fillRect(0,0,artOut.width,artOut.height); ctx.drawImage(artSrc,0,0,artSrc.width,artSrc.height,dx,dy,dw,dh); }

      const bottomOut = mkCanvas(labelPxW,labelPxH);
      { const ctx=bottomOut.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; const srcAR=bottomSrc.width/bottomSrc.height; const dstAR=bottomOut.width/bottomOut.height; let dw,dh,dx,dy; if(srcAR>dstAR){ dw=bottomOut.width; dh=Math.round(dw/srcAR); dx=0; dy=Math.round((bottomOut.height-dh)/2);} else { dh=bottomOut.height; dw=Math.round(dh*srcAR); dx=Math.round((bottomOut.width-dw)/2); dy=0;} ctx.fillStyle='#fff'; ctx.fillRect(0,0,bottomOut.width,bottomOut.height); ctx.drawImage(bottomSrc,0,0,bottomSrc.width,bottomSrc.height,dx,dy,dw,dh); }

      // previews
      ctxTop.drawImage(artOut,0,0); ctxBot.drawImage(bottomOut,0,0);

      // export buffers
      S.topCanvas=artOut; S.bottomCanvas=bottomOut; exportTop.disabled=exportBottom.disabled=false;
    }

    // exports
    function trimWhite(canvas, tolerance=8){
      const w=canvas.width,h=canvas.height; const ctx=canvas.getContext('2d');
      const img=ctx.getImageData(0,0,w,h); const d=img.data; const tol = Math.max(0,Math.min(255,tolerance|0));
      let minX=w, minY=h, maxX=-1, maxY=-1;
      for(let y=0,idx=0;y<h;y++){
        for(let x=0;x<w;x++,idx+=4){
          const r=d[idx], g=d[idx+1], b=d[idx+2], a=d[idx+3];
          // consider any pixel that isn't near-white (or is transparent) as content
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          if(a<250 || lum < 255 - tol){
            if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y;
          }
        }
      }
      if(maxX<minX || maxY<minY) return canvas; // nothing found
      const cw = maxX - minX + 1, ch = maxY - minY + 1;
      const out = document.createElement('canvas'); out.width=cw; out.height=ch;
      out.getContext('2d').drawImage(canvas, minX, minY, cw, ch, 0, 0, cw, ch);
      return out;
    }

    exportTop.addEventListener('click',()=>{
      if(!S.topCanvas) return;
      const src = trimExport.checked ? trimWhite(S.topCanvas, 8) : S.topCanvas;
      const a=document.createElement('a'); a.download='proxy_label_art.png'; a.href=src.toDataURL('image/png'); a.click();
    });
    exportBottom.addEventListener('click',()=>{
      if(!S.bottomCanvas) return;
      const src = trimExport.checked ? trimWhite(S.bottomCanvas, 8) : S.bottomCanvas;
      const a=document.createElement('a'); a.download='proxy_label_text.png'; a.href=src.toDataURL('image/png'); a.click();
    }); a.download='proxy_label_text.png'; a.href=S.bottomCanvas.toDataURL('image/png'); a.click(); });

    // init
    readControls();
  </script>
</body>
</html>
