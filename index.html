<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Proxy Splitter (2‑label)</title>
  <style>
    :root {
      --bg: #0f1115; --panel: #171923; --panel2:#1e2230; --text:#e6e8f0; --muted:#9aa4b2; --accent:#7aa2ff; --accent2:#4fd1c5; --warn:#f6ad55;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #0b0d12, #0f1115 120%);
      color: var(--text);
    }
    .wrap { display: grid; grid-template-columns: 340px 1fr; gap: 16px; padding: 16px; }
    .panel { background: var(--panel); border: 1px solid #23283a; border-radius: 12px; padding: 14px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    h1 { font-size: 18px; margin: 0 0 8px; letter-spacing:.2px }
    h2 { font-size: 14px; margin: 14px 0 8px; color: var(--muted); font-weight:600 }
    label { display:block; margin: 8px 0 4px; color: var(--muted); }
    input[type="number"], input[type="text"], select { width:100%; padding:8px 10px; border-radius:10px; border:1px solid #2a3045; background:var(--panel2); color:var(--text); }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px }
    .btn {
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:10px 12px; border-radius:10px; border:1px solid #2a3045; background:#1b2030; color:var(--text);
      cursor:pointer; user-select:none; transition: .15s ease background, .15s ease transform;
    }
    .btn:hover { background:#232a40 }
    .btn:active { transform: translateY(1px) }
    .btn.primary { background: linear-gradient(180deg, #283b73, #1f2b52); border-color:#31478e; }
    .btn.accent { background: linear-gradient(180deg, #145f56, #0f4740); border-color:#1b7a70; }
    .btn.warn { background: linear-gradient(180deg, #7b4a12, #5a360d); border-color:#9c6019; }
    .muted { color: var(--muted); }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px }
    .card { background: #0f1320; border:1px solid #23283a; border-radius: 12px; padding: 10px }
    .preview-wrap { display:grid; grid-template-columns: 1fr 1fr; gap: 12px }
    canvas { width:100%; background:#0a0c12; border-radius:10px; border:1px solid #23283a }
    .bar { display:flex; gap:8px; flex-wrap:wrap }
    .kbd { font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#0c0f19; border:1px solid #23283a; border-radius:6px; padding:2px 6px; color:#c8d0e0 }
    .slider-row { display:grid; grid-template-columns: 1fr auto; align-items:center; gap:8px }
    input[type="range"] { width:100% }
    .note { font-size:12px; color:var(--muted) }
    .pill { font-size: 11px; padding:2px 8px; border-radius:999px; background:#1e2230; border:1px solid #2a3045; color:#aab3c5 }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="panel">
      <h1>MTG Proxy Splitter <span class="pill">two‑label</span></h1>
      <p class="muted">Split a card image into <em>Art</em> (top label) and <em>Text</em> (bottom label). The tool also relocates the <strong>Name + Mana Cost</strong> band from the top to directly above the lower text block. Outputs two PNGs. Rotation optional (90° clockwise).</p>

      <h2>1) Source image</h2>
      <input id="file" type="file" accept="image/*" />
      <div class="row" style="margin-top:8px">
        <button id="fitPreset" class="btn">Auto preset: Classic frame</button>
        <button id="reset" class="btn warn">Reset sliders</button>
      </div>

      <h2>2) Regions (percent of height)</h2>
      <div class="slider-row">
        <label>Top band height (Name+Mana) <span id="vTop" class="pill"></span></label>
        $110$2
      </div>
      <div class="slider-row">
        <label>Art top <span id="vArtTop" class="pill"></span></label>
        $111$2
      </div>
      <div class="slider-row">
        <label>Art bottom <span id="vArtBot" class="pill"></span></label>
        $156$2
      </div>
      <div class="note">Typical classic frame: Name+Mana ≈ 10–12%, Art ≈ 11% → 56%, remainder is type+rules text.</div>

      <h2>3) Output sizing</h2>
      <div class="grid2">
        <div>
          <label>Label width (mm)</label>
          <input id="mmW" type="number" min="10" max="200" step="0.1" value="50" />
        </div>
        <div>
          <label>Label height (mm)</label>
          <input id="mmH" type="number" min="10" max="200" step="0.1" value="80" />
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label>Export DPI (for pixel sizing)</label>
          <input id="dpi" type="number" min="72" max="600" step="1" value="300" />
        </div>
        <div>
          <label>Rotate 90° clockwise</label>
          <select id="rotate">
            <option value="no">No</option>
            <option value="yes">Yes</option>
          </select>
        </div>
      </div>

      <h2>4) Actions</h2>
      <div class="bar">
        <button id="render" class="btn primary">Render previews</button>
        <button id="exportTop" class="btn accent" disabled>Download Art label</button>
        <button id="exportBottom" class="btn accent" disabled>Download Text label</button>
      </div>
      <p class="note" style="margin-top:8px">Tip: Hold <span class="kbd">Shift</span> while dragging sliders for finer control. This tool doesn’t do grayscale/B&amp;W conversion — your printer app will handle that.</p>
    </section>

    <section class="panel">
      <h2 style="margin-top:0">Previews</h2>
      <div class="preview-wrap">
        <div class="card">
          <div class="bar" style="margin-bottom:6px"><strong>Art (top label)</strong></div>
          <canvas id="prevTop" width="600" height="960"></canvas>
        </div>
        <div class="card">
          <div class="bar" style="margin-bottom:6px"><strong>Text (bottom label)</strong></div>
          <canvas id="prevBottom" width="600" height="960"></canvas>
        </div>
      </div>

      <h2>Guides</h2>
      <div class="note">The colored overlays on the previews show your current slices: <span style="color:#7aa2ff">blue=art</span>, <span style="color:#f6ad55">amber=top band</span>. The lower text region is everything below the art bottom. The exported bottom label stacks <em>Top band</em> above the <em>Lower text</em>.</div>
    </section>
  </div>

  <script>
    // Utility: mm → px at DPI
    function mmToPx(mm, dpi) { return Math.round((mm / 25.4) * dpi); }

    // State
    const S = {
      img: null,
      srcW: 0,
      srcH: 0,
      topPct: 10,
      artTopPct: 11,
      artBotPct: 56,
      labelWmm: 50,
      labelHmm: 80,
      dpi: 300,
      rotate: false,
      topCanvas: null,
      bottomCanvas: null,
    };

    // Elements
    const el = (id) => document.getElementById(id);
    const file = el('file');
    const topBand = el('topBand');
    const artTop = el('artTop');
    const artBot = el('artBot');
    const vTop = el('vTop');
    const vArtTop = el('vArtTop');
    const vArtBot = el('vArtBot');

    const mmW = el('mmW');
    const mmH = el('mmH');
    const dpi = el('dpi');
    const rotate = el('rotate');

    const fitPreset = el('fitPreset');
    const resetBtn = el('reset');
    const renderBtn = el('render');
    const exportTop = el('exportTop');
    const exportBottom = el('exportBottom');

    const prevTop = el('prevTop');
    const prevBottom = el('prevBottom');

    // Load image
    file.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const img = new Image();
      img.onload = () => {
        S.img = img; S.srcW = img.naturalWidth; S.srcH = img.naturalHeight;
        drawPreviews();
      };
      img.src = URL.createObjectURL(f);
    });

    // Sliders → state
    function syncLabels(){
      vTop.textContent = S.topPct + '%';
      vArtTop.textContent = S.artTopPct + '%';
      vArtBot.textContent = S.artBotPct + '%';
    }

    function clampRanges(){
      // Ensure: topBand <= artTop < artBot
      if (S.topPct >= S.artTopPct) { S.artTopPct = S.topPct + 1; }
      if (S.artTopPct >= S.artBotPct) { S.artBotPct = S.artTopPct + 1; }

      // Boundaries
      S.topPct = Math.max(3, Math.min(20, S.topPct));
      S.artTopPct = Math.max(10, Math.min(35, S.artTopPct));
      S.artBotPct = Math.max(45, Math.min(70, S.artBotPct));

      topBand.value = S.topPct;
      artTop.value = S.artTopPct;
      artBot.value = S.artBotPct;
      syncLabels();
    }

    function readControls(){
      S.topPct = parseInt(topBand.value,10);
      S.artTopPct = parseInt(artTop.value,10);
      S.artBotPct = parseInt(artBot.value,10);
      S.labelWmm = parseFloat(mmW.value);
      S.labelHmm = parseFloat(mmH.value);
      S.dpi = parseInt(dpi.value,10);
      S.rotate = (rotate.value === 'yes');
      clampRanges();
    }

    [topBand, artTop, artBot, mmW, mmH, dpi, rotate].forEach(inp => {
      inp.addEventListener('input', () => { readControls(); drawPreviews(); });
    });

    fitPreset.addEventListener('click', () => {
      // Classic estimates
      topBand.value = 10; artTop.value = 11; artBot.value = 56;
      readControls(); drawPreviews();
    });

    resetBtn.addEventListener('click', () => {
      topBand.value = 10; artTop.value = 11; artBot.value = 56;
      mmW.value = 50; mmH.value = 80; dpi.value = 300; rotate.value = 'no';
      readControls(); drawPreviews();
    });

    renderBtn.addEventListener('click', () => { readControls(); drawPreviews(true); });

    // Core logic
    function cropCanvas(srcImg, sx, sy, sw, sh) {
      const c = document.createElement('canvas');
      c.width = Math.max(1, Math.round(sw)); c.height = Math.max(1, Math.round(sh));
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(srcImg, sx, sy, sw, sh, 0, 0, c.width, c.height);
      return c;
    }

    function stackVertical(canvases, outW, outH) {
      const c = document.createElement('canvas');
      c.width = outW; c.height = outH;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#fff'; ctx.fillRect(0,0,outW,outH);
      let y = 0;
      canvases.forEach(cv => {
        const h = Math.round((cv.height / canvases.reduce((s,x)=>s+x.height,0)) * outH);
        ctx.drawImage(cv, 0, y, outW, h);
        y += h;
      });
      return c;
    }

    function rotate90cw(canvas) {
      const c = document.createElement('canvas');
      c.width = canvas.height; c.height = canvas.width;
      const ctx = c.getContext('2d');
      ctx.translate(c.width, 0); ctx.rotate(Math.PI/2);
      ctx.drawImage(canvas, 0, 0);
      return c;
    }

    function drawGuides(ctx, w, h, topPx, aTopPx, aBotPx) {
      // Guides: art region and top band
      ctx.save();
      ctx.fillStyle = 'rgba(122,162,255,0.18)';
      ctx.fillRect(0, aTopPx, w, aBotPx - aTopPx);
      ctx.fillStyle = 'rgba(246,173,85,0.18)';
      ctx.fillRect(0, 0, w, topPx);
      ctx.restore();
    }

    function drawPreviews(enableExport=false) {
      syncLabels();
      const ctxTop = prevTop.getContext('2d');
      const ctxBot = prevBottom.getContext('2d');
      ctxTop.clearRect(0,0,prevTop.width,prevTop.height);
      ctxBot.clearRect(0,0,prevBottom.width,prevBottom.height);

      if (!S.img) { exportTop.disabled = true; exportBottom.disabled = true; return; }

      // Calculate slices in source pixels
      const H = S.srcH, W = S.srcW;
      const topPx = Math.round(H * (S.topPct/100));
      const artTopPx = Math.round(H * (S.artTopPct/100));
      const artBotPx = Math.round(H * (S.artBotPct/100));
      const lowerTextTopPx = artBotPx; // from art bottom to end

      // Crops
      const topBandC = cropCanvas(S.img, 0, 0, W, topPx);
      const artC = cropCanvas(S.img, 0, artTopPx, W, artBotPx - artTopPx);
      const lowerTextC = cropCanvas(S.img, 0, lowerTextTopPx, W, H - lowerTextTopPx);

      // Build bottom label by stacking: [topBand] above [lower text]
      const labelPxW = mmToPx(S.labelWmm, S.dpi);
      const labelPxH = mmToPx(S.labelHmm, S.dpi);

      // Fit art to label size (preserve aspect by covering height)
      const artOut = document.createElement('canvas');
      artOut.width = labelPxW; artOut.height = labelPxH;
      {
        const ctx = artOut.getContext('2d');
        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        // Draw art covering the whole label (letterbox if needed)
        const srcCanvas = S.rotate ? rotate90cw(artC) : artC;
        const srcAR = srcCanvas.width / srcCanvas.height;
        const dstAR = artOut.width / artOut.height;
        let dw, dh, dx, dy;
        if (srcAR > dstAR) {
          // source wider than dest → fit width
          dw = artOut.width; dh = Math.round(dw / srcAR); dx = 0; dy = Math.round((artOut.height - dh)/2);
        } else {
          dh = artOut.height; dw = Math.round(dh * srcAR); dx = Math.round((artOut.width - dw)/2); dy = 0;
        }
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,artOut.width,artOut.height);
        ctx.drawImage(srcCanvas, 0, 0, srcCanvas.width, srcCanvas.height, dx, dy, dw, dh);
      }

      // Bottom label: stack topBandC + lowerTextC, then scale to label size
      const stackedRaw = stackVertical([topBandC, lowerTextC], W, topBandC.height + lowerTextC.height); // keep source width
      const bottomOut = document.createElement('canvas');
      bottomOut.width = labelPxW; bottomOut.height = labelPxH;
      {
        const ctx = bottomOut.getContext('2d');
        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        const srcCanvasB = S.rotate ? rotate90cw(stackedRaw) : stackedRaw;
        const srcAR = srcCanvasB.width / srcCanvasB.height;
        const dstAR = bottomOut.width / bottomOut.height;
        let dw, dh, dx, dy;
        if (srcAR > dstAR) {
          dw = bottomOut.width; dh = Math.round(dw / srcAR); dx = 0; dy = Math.round((bottomOut.height - dh)/2);
        } else {
          dh = bottomOut.height; dw = Math.round(dh * srcAR); dx = Math.round((bottomOut.width - dw)/2); dy = 0;
        }
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,bottomOut.width,bottomOut.height);
        ctx.drawImage(srcCanvasB, 0,0, srcCanvasB.width, srcCanvasB.height, dx, dy, dw, dh);
      }

      // Draw to previews
      prevTop.width = artFinal.width; prevTop.height = artFinal.height;
      prevBottom.width = bottomFinal.width; prevBottom.height = bottomFinal.height;
      ctxTop.drawImage(artFinal, 0, 0);
      ctxBot.drawImage(bottomFinal, 0, 0);

      // Overlay guides from source proportions for context
      // (Scaled to preview canvas sizes proportionally)
      ctxTop.save(); ctxBot.save();
      // The guides are based on the original; here, just annotate the previews with stripes near top positions.
      // Since art preview is cropped, we'll just show a small legend strip; keep simple.
      ctxTop.restore(); ctxBot.restore();

      // Store for export
      S.topCanvas = artOut; S.bottomCanvas = bottomOut;
      exportTop.disabled = exportBottom.disabled = false;
    }

    exportTop.addEventListener('click', () => {
      if (!S.topCanvas) return;
      const a = document.createElement('a'); a.download = 'proxy_label_art.png'; a.href = S.topCanvas.toDataURL('image/png'); a.click();
    });
    exportBottom.addEventListener('click', () => {
      if (!S.bottomCanvas) return;
      const a = document.createElement('a'); a.download = 'proxy_label_text.png'; a.href = S.bottomCanvas.toDataURL('image/png'); a.click();
    });

    // Init
    readControls(); syncLabels();
  </script>
</body>
</html>
